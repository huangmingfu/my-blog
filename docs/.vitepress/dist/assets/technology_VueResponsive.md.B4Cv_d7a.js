import{j as s,b as i,c as a,aa as n}from"./chunks/framework.BSznDLKk.js";const y=JSON.parse('{"title":"☠ Vue2/3 响应式原理剖析","description":"","frontmatter":{"sticky":999,"tag":["Technology"]},"headers":[],"relativePath":"technology/VueResponsive.md","filePath":"technology/VueResponsive.md","lastUpdated":1711110799000}'),h={name:"technology/VueResponsive.md"},l=n(`<h1 id="☠-vue2-3-响应式原理剖析" tabindex="-1">☠ Vue2/3 响应式原理剖析 <a class="header-anchor" href="#☠-vue2-3-响应式原理剖析" aria-label="Permalink to &quot;☠ Vue2/3 响应式原理剖析&quot;">​</a></h1><h2 id="一、vue2" tabindex="-1">一、Vue2 <a class="header-anchor" href="#一、vue2" aria-label="Permalink to &quot;一、Vue2&quot;">​</a></h2><h3 id="响应式原理" tabindex="-1">响应式原理： <a class="header-anchor" href="#响应式原理" aria-label="Permalink to &quot;响应式原理：&quot;">​</a></h3><h4 id="_1-对象" tabindex="-1">1.对象 <a class="header-anchor" href="#_1-对象" aria-label="Permalink to &quot;1.对象&quot;">​</a></h4><blockquote><p><strong>Vue.js 2.x 中的响应式是通过使用 ES5 的 Object.defineProperty() 方法实现的。这个方法允许我们定义一个对象的属性，其中包括 getter 和 setter。当对象的属性被访问或者修改时，这些 getter 和 setter 会被调用，这就是 Vue 的响应式实现。（一次只能监听一个属性，如果需要监听多个属性，你需要对每个属性都调用一次 Object.defineProperty()，遇到深层对象，需要进行递归遍历）</strong></p></blockquote><h4 id="_2-数组" tabindex="-1">2.数组 <a class="header-anchor" href="#_2-数组" aria-label="Permalink to &quot;2.数组&quot;">​</a></h4><blockquote><p><strong>Vue 2.x 中监听数组的方式是通过重写数组的变异方法（mutator methods），比如 push()、pop()、shift()、unshift()、splice()、sort() 和 reverse() 等。Vue 在这些方法被调用时，会触发视图的更新。</strong></p></blockquote><h4 id="_3-object-defineproperty-的简单认识" tabindex="-1">3.Object.defineProperty 的简单认识 <a class="header-anchor" href="#_3-object-defineproperty-的简单认识" aria-label="Permalink to &quot;3.Object.defineProperty 的简单认识&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义一个新的属性 &#39;name&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取属性值时的操作</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`获取属性 \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">internalValue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> internalValue;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 设置属性值时的操作</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`设置属性 \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">newValue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    internalValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newValue;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 这里可以添加额外的响应逻辑，比如更新UI等</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 设置属性的值为 &#39;John&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  value: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;John&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 设置属性为可写的</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  writable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 设置属性为可枚举的，即可被遍历</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  enumerable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 设置属性为可配置的，即可修改或删除</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  configurable: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="二、vue3" tabindex="-1">二、Vue3 <a class="header-anchor" href="#二、vue3" aria-label="Permalink to &quot;二、Vue3&quot;">​</a></h2><h3 id="响应式原理-1" tabindex="-1">响应式原理： <a class="header-anchor" href="#响应式原理-1" aria-label="Permalink to &quot;响应式原理：&quot;">​</a></h3><h4 id="_1-对象-1" tabindex="-1">1.对象 <a class="header-anchor" href="#_1-对象-1" aria-label="Permalink to &quot;1.对象&quot;">​</a></h4><blockquote><p><strong>Vue3 主要基于 ES6 的 Proxy 对象和 Reflect 对象，使用 Proxy 对象来监听对象的属性的变化。当对对象的属性进行修改、添加或删除时，Proxy 会捕获到这些变化并触发相应的更新。</strong></p></blockquote><h4 id="_2-数组-1" tabindex="-1">2.数组 <a class="header-anchor" href="#_2-数组-1" aria-label="Permalink to &quot;2.数组&quot;">​</a></h4><blockquote><p><strong>同样地，Vue 3 使用 Proxy 对象来监听数组的变化，包括对数组的元素的修改、添加和删除。当对数组进行变化操作时，Proxy 会捕获到这些变化并触发相应的更新。</strong></p></blockquote><h4 id="_3-基本数据类型" tabindex="-1">3.基本数据类型 <a class="header-anchor" href="#_3-基本数据类型" aria-label="Permalink to &quot;3.基本数据类型&quot;">​</a></h4><blockquote><p><strong>类似于 Vue2，将基本类型包装在一个内部对象中，然后对这个对象进行代理</strong></p></blockquote><h4 id="_3-proxy-和-reflect-的简单认识" tabindex="-1">3.Proxy 和 Reflect 的简单认识 <a class="header-anchor" href="#_3-proxy-和-reflect-的简单认识" aria-label="Permalink to &quot;3.Proxy 和 Reflect 的简单认识&quot;">​</a></h4><div class="tip custom-block"><p class="custom-block-title">Proxy</p><p>const p = new Proxy(target, handler)<br><strong>参数:</strong><br> target:要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）<br> handler:一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</p><p><strong>注意：</strong><br> 1.Proxy 可以代理对象、数组，不能代理基本数据类型，会报错。Proxy 常常搭配 Reflect 使用</p><p>2.访问 proxyObj 的深层属性时，并不会触发 set。所以 proxy 如果想实现深度监听，也需要实现一个递归函数, 使用 proxy 逐个对对象中的每个属性进行拦截</p><p>3.直接 Proxy 代理是懒代理：<br>     set：只对第一层监听，只能拦截直接属性的赋值<br>     get：无论几层都可以监听到，不存在的属性仍然可以被 get 拦截到</p><p>4.代理数组：<br> push 时会触发两次 get 和两次 set，这和 push 的实现原理有关：push 操作除了增加数组的数据项之外，也会引发数组本身其他相关属性的改变；<br> proxyArr[1]这种修改只会执行一次。</p></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个简单的对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;张三&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  family: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    father: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;李四&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在获取属性时拦截</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`获取属性：\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target[key];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在设置属性时拦截</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`设置属性：\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} 值：\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    target[key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建代理对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxyObj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, handler);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//执行了get</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(proxyObj.name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//输出：获取属性：name (张三)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行了set</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">proxyObj.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//输出：设置属性：age 值：35</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//执行了get</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">proxyObj.family.father </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;王五&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//输出：获取属性：family</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//执行了set</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">proxyObj.family </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { a: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//输出：设置属性：family 值：{a:&#39;test&#39;}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//执行了get</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(proxyObj.family.father); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//输出：获取属性：family (李四)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//执行了get</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(proxyObj.family.mother); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//输出：获取属性：family (undefined)</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* Reflect对象（内置）提供了一组与Proxy对象的拦截操作对应的方法 */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;John&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  age: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">receiver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`获取属性：\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">prop</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, prop, receiver); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 Reflect.get 方法获取属性值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">prop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">receiver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`设置属性：\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">prop</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} to \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, prop, value, receiver); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 Reflect.set 方法设置属性值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> proxy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, handler);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(proxy.name); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 获取属性：name，然后输出 John</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">proxy.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 35</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 设置属性：age to 35</span></span></code></pre></div><h2 id="三、vue2-和-vue3-比较" tabindex="-1">三、Vue2 和 Vue3 比较 <a class="header-anchor" href="#三、vue2-和-vue3-比较" aria-label="Permalink to &quot;三、Vue2 和 Vue3 比较&quot;">​</a></h2><h3 id="选项式-api-和组合式-api" tabindex="-1">选项式 api 和组合式 api <a class="header-anchor" href="#选项式-api-和组合式-api" aria-label="Permalink to &quot;选项式 api 和组合式 api&quot;">​</a></h3><blockquote><p><strong><code>选项 API（Options API）</code></strong>：这是 Vue 2 中最常见的一种方式，通过在组件选项中声明 data、methods、computed、watch 等来组织代码。它将相关功能按照选项的形式组织在一起，使得组件的结构相对清晰，适合较小规模的应用或者新手入门。<br><strong><code>组合式 API（Composition API）</code></strong>：这是 Vue 3 中引入的一种全新的 API，它允许开发者根据逻辑功能来组织代码，而不是按照固定的选项。它提供了 setup 函数，使得代码更加灵活和可复用，尤其适用于大型应用或者需要更高度组织的情况。<br><strong><code>比较：</code></strong> Vue 2 的选项 API 一旦项目大起来功能越来越多，维护就变得困难。Vue 3 的组合式 API 很好的解决了这一问题，因为它可以将某一个功能模块放在一起。</p></blockquote><h3 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h3><blockquote><p>setup：相当于 vue2 前的 created 周期-&gt;创建时（beforeCreate 和 created 的结合）<br> onBeforeMount：DOM 即将挂载<br> onMounted：DOM 挂载完毕<br> onBeforeUpdate：DOM 即将更新<br> onUpdated：DOM 更新完毕<br> onBeforeUnmount：即将销毁<br> onUnmounted：销毁完毕</p></blockquote><blockquote><p>添加了路由缓存后新增两个（当卸载和重新进去组件后只会执行这两个）：<br> onActivated 和 onDeactivated</p></blockquote><h3 id="v-for-和-v-if-优先级" tabindex="-1">v-for 和 v-if 优先级 <a class="header-anchor" href="#v-for-和-v-if-优先级" aria-label="Permalink to &quot;v-for 和 v-if 优先级&quot;">​</a></h3><blockquote><p><code>vue2</code> v-for 优先级更大：v-if &lt; v-for<br><code>vue3</code> v-if 优先级更大：v-if &gt; v-for</p></blockquote><h3 id="diff-算法的优化" tabindex="-1">diff 算法的优化 <a class="header-anchor" href="#diff-算法的优化" aria-label="Permalink to &quot;diff 算法的优化&quot;">​</a></h3><blockquote><p>当数据发生改变的时候，vue 会生成新的 dom 树，然后和之前的 dom 树进行比较，也就是新旧虚拟 dom 的一个对比，但是在 vue2 中这是一个全量的比较，它是每一个节点都会进行比较，没有变化的静态内容也会进行比较，会消耗一些时间。 怎么样快速区别出更新的内容，这就是 vue3 所优化的一个地方。它是根据节点会不会发生变化来添加静态标记、动态标记，而后比较时会忽略所有的静态节点，只对有标记的动态节点进行对比，而且在多层的嵌套下依然有效，提高了效率。</p></blockquote><h3 id="静态提升" tabindex="-1">静态提升 <a class="header-anchor" href="#静态提升" aria-label="Permalink to &quot;静态提升&quot;">​</a></h3><blockquote><p>以前 vue2 不管元素有没有更新，每次都会创建然后渲染。 vue3 使用静态提升后，静态元素页面初始的时候只渲染一次，而在更新渲染的时候，不需要再创建，提升性能</p></blockquote><h3 id="事件监听缓存" tabindex="-1">事件监听缓存 <a class="header-anchor" href="#事件监听缓存" aria-label="Permalink to &quot;事件监听缓存&quot;">​</a></h3><blockquote><p>以前事件是一个动态绑定，追踪变化，现在是缓存起来进行复用，以减少事件绑定的开销</p></blockquote><h3 id="响应式实现方式的升级" tabindex="-1">响应式实现方式的升级 <a class="header-anchor" href="#响应式实现方式的升级" aria-label="Permalink to &quot;响应式实现方式的升级&quot;">​</a></h3><blockquote><p>Vue2 用 object.defineProties 有以下几个缺点： 1.一次只能对一个属性进行监听，需要遍历来对所有属性监听； 2.在遇到一个对象的属性还是一个对象的情况下，需要递归监听，会消耗一些时间、性能；<br> 3.新增的对象属性监听不到，需要进行手动监听（vue2 通过$set 解决）；<br> 4.对于数组通过 push、unshift 方法增加的元素，无法监听（vue2 通过改写数组方法解决）。</p></blockquote><p>vue3 用 proxy 后直接监听整个对象，无论嵌套多少层都可以监听到（proxy 的 get 方法），同样对数组适用,基本类型是包装在一个内部对象中，然后对这个对象进行代理。</p><h3 id="vue2-和-vue3-组件通信对比" tabindex="-1">vue2 和 vue3 组件通信对比 <a class="header-anchor" href="#vue2-和-vue3-组件通信对比" aria-label="Permalink to &quot;vue2 和 vue3 组件通信对比&quot;">​</a></h3><p><img src="https://friend-z.gitee.io/drawing-bed/images/technology/blog-tread-02.png" alt="" loading="lazy"></p>`,40),t=[l];function e(p,k,r,E,d,o){return i(),a("div",null,t)}const c=s(h,[["render",e]]);export{y as __pageData,c as default};
